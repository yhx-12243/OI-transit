<!DOCTYPE html>
<html lang="zh-cn">
	<head>
		<meta charset="utf-8">
		<link type="text/css" rel="stylesheet" href="../additional_files/css/bootstrap.min.css">
		<link type="text/css" rel="stylesheet" href="../additional_files/css/sh_typical.min.css">
		<title>[lydsy5498][lg5289][loj3051][12 省联测 2019]皮配</title>
		<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$', '$']], displayMath: [['$$', '$$']]}});</script>
		<script src="../additional_files/js/sh_main.min.js"></script>
		<script src="../additional_files/MathJax-master/MathJax.js?config=TeX-MML-AM_CHTML"></script>
	</head>
	<body>
		<h3>题目描述</h3>
		<p>一年一度的综艺节目《中国好码农》又开始了。本季度，好码农由 Yazid、Zayid、小 R、大 R 四位梦想导师坐镇，他们都将组建自己的梦想战队，并率领队员向梦想发起冲击。</p>
		<p>四位导师的<strong>派系</strong>不尽相同，节目组为了营造看点，又将导师分成了不同的<strong>阵营</strong>，与此同时对不同阵营、不同派系都作出了战队总人数限制：</p>
		<ul>
			<li><p>四位导师分成两个<strong>阵营</strong>：</p>
			<ul>
				<li><p>Yazid、小 R 两位导师组成<strong>蓝阵营</strong>，他们两位的战队人数<strong>总和</strong>不得超过 $C_0$。</p></li>
				<li><p>Zayid、大 R 两位导师组成<strong>红阵营</strong>，他们两位的战队人数<strong>总和</strong>不得超过 $C_1$。</p></li>
			</ul></li>
			<li><p>四位导师分成两个<strong>派系</strong>：</p>
			<ul>
				<li><p>Yazid、Zayid 两位导师属于<strong>鸭派系</strong>，他们两位的战队人数<strong>总和</strong>不得超过 $D_0$。</p></li>
				<li><p>小 R、大 R 两位导师属于 <strong>R 派系</strong>，他们两位的战队人数<strong>总和</strong>不得超过 $D_1$。</p></li>
			</ul></li>
		</ul>
		<p>本季好码农邀请到了全国各路学生精英参赛。他们来自全国 $c$ 个城市的 $n$ 所不同学校 (城市的编号从 $1$ 至 $c$，学校的编号从 $1$ 至 $n$)。其中，第 $i$ 所学校所属的城市编号为 $b_i$，且共有 $s_i$ 名选手参赛。</p>
		<p>在各总人数限制之外，本季度《中国好码农》的导师选择阶段有额外规则如下：</p>
		<ul>
			<li><p>来自同<strong>城市</strong>的所有选手必须加入相同的<strong>阵营</strong>。</p></li>
			<li><p>来自同<strong>学校</strong>的所有选手必须选择相同的<strong>导师</strong>。</p></li>
		</ul>
		<p>对于导师，大部分学校的学生对导师没有<strong>偏好</strong>。但是有 $k$ 所学校，其中每所学校的学生有且仅有一位他们不喜欢的导师。同一所学校的学生不喜欢的导师相同，他们<strong>不会加入他们不喜欢的导师的战队</strong>。</p>
		<p>面对琳琅满目的规则和选手的偏好，作为好码农忠实观众的你想计算出，在所有选手都进行了战队选择后，战队组成共有多少种可能的局面？</p>
		<ul>
			<li><p>两种战队组成的局面被认为是不同的，当且仅当在存在一所学校，使得在这两种局面中这所学校的选手加入了不同导师的战队。</p></li>
			<li><p>由于答案可能很大，你只需输出可能局面数对 $998\,244\,353$ 取模的结果即可。</p></li>
		</ul>

		<h3>输入格式</h3>
		<p>输入包含多组数据。</p>
		<p>第一行包含一个非负整数 $T$ ($T \leq 5$)，表示数据组数。</p>
		<p>接下来依次描述每组数据，对于每组数据：</p>
		<p>第一行包含两个正整数 $n, c$ ($1 \leq c \leq n \leq 1000$)，分别表示学校数目、城市数目。</p>
		<p>第二行包含四个正整数 $C_0, C_1, D_0, D_1$ ($1 \leq C_0, C_1, D_0, D_1 \leq 2500$)，分别表示题目中所描述的四个限制。</p>
		<p>接下来 $n$ 行，每行 $2$ 个正整数 $b_i, s_i$ ($b_i \leq c; s_i \leq \min \left\{ M, 10 \right\}$，其中 $M = \max \left\{ C_0, C_1, D_0, D_1 \right\}$)，分别表示第 $i$ 所学校的所属城市以及选手数目。</p>
		<p>第 $n + 3$ 行包含一个非负整数 $k$ ($k \leq 30$)，表示选手有偏好的学校数目。</p>
		<p>接下来 $k$ 行，每行 $2$ 个非负整数 $i, p$ ($1 \leq i \leq n; 0 \leq p \leq 3$，所有的 $i$ 护手相同)，描述编号为 $i$ 的学校选手不喜欢的导师：0 代表 Yazid，1 代表小 R，2 代表 Zayid，3 代表大 R。</p>
		<p>对于输入的每一行，如果其包含多个数，则用单个空格将它们隔开。</p>

		<h3>输出格式</h3>
		<p>对于每组数据，输出一行一个整数，表示可能局面数对 $998\,244\,353$ 取模的结果。</p>

		<h3>题解</h3>
		<p>先转化人数总和的限制。由于每个选手<strong>恰好</strong>选择一个<strong>阵营</strong>和一个<strong>派系</strong>，因此我们可以将人数限制转化为<strong>单个阵营和派系的人数限制区间</strong>。不妨设红阵营的人数范围为 $\left[ L_y, R_y \right]$，R 派系的人数范围为 $\left[ L_x, R_x \right]$。</p>
		<p>考虑使用 (二元) 生成函数，我们对于<strong>红阵营</strong>，每出现一个人，贡献一个 $y$，否则贡献为 $1$；对于 <strong>R 派系</strong>，每出现一个人，贡献一个 $x$。则最后多项式 $x^a y^b$ 项的系数就表示<strong>红阵营有 $a$ 个人，蓝阵营有 $b$ 个人</strong>的方案数。</p>
		<p>设最终的生成函数为 $Ans \left( x, y \right)$，那么最终的答案就是 $\displaystyle \sum_{a = L_x}^{R_x} \sum_{b = L_y}^{R_y} \left[ x^a y^b \right] Ans \left( x, y \right)$。</p>
		<p>先考虑 $k = 0$ 的情形，即没有选手有偏好。</p>
		<p>此时，考虑每个学校，它可以有<strong>蓝阵营</strong>和<strong>红阵营</strong>的选择，因此是 $1 + x^{s_i}$；对于每个城市，可以有<strong>鸭派系</strong>和 <strong>R 派系</strong>两种选择，设该城市共有 $S_j$ 个人，则贡献为 $1 + y^{S_j}$。</p>
		<p>于是 $\displaystyle Ans \left( x, y \right) = \left( \prod_{i=1}^n \left( 1 + x^{s_i} \right) \right) \left( \prod_{j=1}^c \left( 1 + y^{S_j} \right) \right)$。</p>
		<p>容易发现 $Ans \left( x, y \right)$ 中的这些项关于 $x$ 和 $y$ 是独立的 (即 $Ans \left( x, y \right)$ 可以分解乘两个因式的积，其中一个因式<strong>只</strong>和 $x$ 有关，另一个因式<strong>只</strong>和 $y$ 有关)。因此，我们可以先把 $\displaystyle f_x \left( x \right) = \prod_{i=1}^n \left( 1 + x^{s_i} \right)$ 和 $\displaystyle f_y \left( y \right) = \prod_{j=1}^c \left( 1 + y^{S_j} \right)$ 计算出来，然后暴力做一次卷积即可，有 $Ans \left( x, y \right) = f_x \left( x \right) \cdot f_y \left( y \right)$。</p>
		<p>时间复杂度为 $O \left( M^2 \right)$ (由于 $R_x, R_y \leq M$，因此所有多项式操作均可以在 $\hspace{-0.444em} \pmod {x^{R_x + 1}, y^{R_y + 1}}$ 意义下进行)。</p>
		<hr />
		<p>对于 $k \neq 0$ 的情形，又该怎么处理呢？</p>
		<p>考察一个有偏好的学校 $i$，设 $i$ 不喜欢某个导师 (某个阵营中的某个派系)，不妨设是小 R。</p>
		<p>考虑该学校所在的城市 $j$，有两种选择：</p>
		<ol>
			<li><p>它可以选择<strong>蓝阵营</strong>，此时 $i$ 校<strong>不能产生 $x^{c_i}$ 的贡献</strong>，因此项 $1 + x^{c_i}$ 需要改成 $1$。</p></li>
			<li><p>它也可以选择<strong>红阵营</strong>，此时 $i$ 校<strong>不产生影响</strong>，贡献依然是项 $1 + x^{c_i}$。</p></li>
		</ol>
		<p>对 $i$ 不喜欢大 R、Yazid、Zayid 的情况都是类似的，<del>具体见代码</del>。</p>
		<p>于是，这个城市 $j$ 对应的贡献需要写成两项：$1 \cdot \left( 1 + x^{s_1} \right) \cdot \left( 1 + x^{s_2} \right) \cdot \cdots$，以及 $y^{S_j} \cdot \left( 1 + x^{s_1} \right) \cdot \left( 1 + x^{s_2} \right) \cdot \cdots$。由于出现不喜欢某个导师的情况，所以两项的右边一般是不相等的，因此无法提取出公因式。</p>
		<p>不过注意到 $k \leq 30$ —— 也就是说，大多数的多项式还是规规矩矩地，可以提取出公因式的。</p>
		<p>因此，对于不偏好的学校 $i$，在最终的答案生成函数中，依然存在 $1 + x^{s_i}$ 作为因式；对于所有学校都不偏好的城市 $j$，在答案生成函数中，也会存在 $1 + y^{S_j}$。也就是说，对于这些项，还是可以像上面 $k = 0$ 的算法一样，先计算出来。</p>
		<p>对于特殊的情况 (存在有偏好的学校)，我们采取<strong>暴力更新</strong>的措施。</p>
		<p>设当前的生成函数为 $f_0 \left( x, y \right)$，考虑加入一个 (有偏好的) 城市，设它取蓝阵营后的生成函数为 $B \left( x \right)$，取红阵营后的生成函数为 $y^{S_i} \cdot R \left( x \right)$，则新的 $f_1 \left( x, y \right) = f_0 \left( x, y \right) \cdot \left( B \left( x \right) + y^{S_i} R \left( x \right) \right)$，因此我们只需把一种情况搞清楚，最后相加即可。</p>
		<p>考虑蓝阵营的情况。容易发现，这个城市中的每个 (有偏好的) 学校，都能对应着一个二项式 $1 + x^{s_i}$ 或单项式 $1$/$x^{s_i}$。我们将这个二项式 (或单项式) 与 $f_0 \left( x, y \right)$ 作暴力乘法，容易发现这是 $O \left( M^2 \right)$ 的。</p>
		<p>由于有偏好的学校不超过 $k$ 个，因此这样的乘法至多进行 $O \left( k \right)$ 次 (其实不超过 $2 k$ 次)，因此我们可以在 $O \left( k M^2 \right)$ 的时间内得到 $Ans \left( x, y \right)$，期望得分 $90$ 分，<del>如果你是 wys 就有可能获得 $100$ 分</del>。</p>
		<hr />
		<p>其实这个复杂度还是不够优秀，存在更优的做法。</p>
		<p>考虑我们计算 $f_1 \left( x, y \right) = f_0 \left( x, y \right) \cdot \left( B \left( x \right) + y^{S_i} R \left( x \right) \right)$ 的过程。我们并不需要对于每个 (有偏好的) 城市，马上去更新 $f_j \left( x, y \right)$，而是可以考虑将其 "屯" 起来，最后直接更新 $f_0 \left( x, y \right)$。</p>
		<p>于是我们就需要算若干 $B_j \left( x \right) + y^{S_j} R_j \left( x \right)$ 的乘积，考虑暴力计算这个乘积 (还是二项式更新，只是初项不再是 $f_0 \left( x, y \right)$，而是单位元 $1$)。</p>
		<p>神奇的事情又发生了！<strong style="color: red">由于 $s_i \leq 10$，且这样的二项式不超过 $k$ 个，因此最后总的多项式的次数不超过 $k \cdot s_i$！</strong>
		<p>因此，如果我们这样暴力计算，计算出所有 $B_j \left( x \right) + y^{S_j} R_j \left( x \right)$ 的乘积的复杂度是 $O \left( k \cdot \left( k \cdot s_i \right)^2 \right) = O \left( k^3 s_i^2 \right)$ (注意是<strong>二元</strong>多项式哦)！</p>
		<p>记这个成绩为 $P_l \left( x, y \right)$。最后的事情，就是计算 $Ans \left( x, y \right) = f_0 \left( x, y \right) \cdot P_l \left( x, y \right)$。</p>
		<p>不过这两个多项式暴力卷积是 $O \left( M^2 k^2 s_i^2 \right)$ 的，根本无法接受，且用 NTT 计算也不太现实，我们似乎又遇到了瓶颈！</p>
		<p>不过我们注意到题目要求的，并不是 $Ans \left( x, y \right)$ 的<strong>每一项系数</strong>，而是 ("系数矩阵" 中) 一个 "矩形区间" 的系数和，这引导我们使用<strong>前缀和优化</strong>！</p>
		<p>枚举 $f_0 \left( x, y \right)$ 中的项 $x^a y^b$，则在 $P_l \left( x, y \right)$ 中，$x$ 的次数应在区间 $\left[ L_x - a, R_x - a \right]$ 中，$y$ 的次数应在区间 $\left[ L_y - b, R_y - b \right]$ 内。</p>
		<p>可以发现，我们只需要求出 $P_l \left( x, y \right)$ 的 "系数矩阵" 中一个 "矩形区间" 的系数和。因此，我们对 $P_l \left( x, y \right)$ 的 "系数矩阵" 做一遍<strong>二维前缀和</strong>，就彻底地解决了这个问题。</p>
		<p>总时间复杂度 $O \left( n M + M^2 + k^3 s_i^2 \right)$。</p>

		<h3>代码</h3>

		<div class="panel-body"><pre class="sh_sourceCode"><code class="sh_cpp">#include &lt;bits/stdc++.h&gt;
#define repjk for (j = 0; j &lt;= Dy; ++j) {for (k = Dx; k &gt;= s[sc]; --k)

typedef long long ll;
typedef std::vector &lt;int&gt; vector;
const int N = 2540, mod = 998244353;

int n, K, C;
int S, Lx, Rx, Ly, Ry;
int b[N], s[N], ban[N];
vector c[N];
bool banC[N];
int f[N][N], g[N][N], fx[N], fy[N];

inline void up(int &amp;x, const int y) {x &lt; y ? x = y : 0;}
inline int min(const int x, const int y) {return x &lt; y ? x : y;}
inline int max(const int x, const int y) {return x &lt; y ? y : x;}
inline void add(int &amp;x, const int y) {x += y - mod, x += x &gt;&gt; 31 &amp; mod;}

inline int range_sum(int Lx, int Rx, int Ly, int Ry) {
	ll s = f[Ry][Rx];
	Lx &gt; 0 &amp;&amp; (s -= f[Ry][Lx - 1]);
	Ly &gt; 0 &amp;&amp; (s -= f[Ly - 1][Rx]);
	Lx &gt; 0 &amp;&amp; Ly &gt; 0 &amp;&amp; (s += f[Ly - 1][Lx - 1]);
	return s % mod + (s &gt;&gt; 63 &amp; mod);
}

void work() {
	int i, j, k, p, Dx, Dy; ll Fy = 0;
	scanf("%d%d%d%d%d%d", &amp;n, &amp;C, &amp;Ly, &amp;Ry, &amp;Lx, &amp;Rx);
	for (i = 1; i &lt;= C; ++i) c[i].clear();
	memset(ban, -1, sizeof ban), memset(banC, false, sizeof banC);
	for (S = 0, i = 1; i &lt;= n; ++i) scanf("%d%d", b + i, s + i), S += s[i], c[b[i]].emplace_back(i);
	for (scanf("%d", &amp;K), i = 0; i &lt; K; ++i) scanf("%d%d", &amp;j, &amp;p), ban[j] = p, banC[b[j]] = true;
	Lx = max(S - Lx, 0), Ly = max(S - Ly, 0);
	if (Lx &gt; Rx || Ly &gt; Ry) {putchar(48), putchar(10); return;}

	memset(fx, 0, sizeof fx), memset(fy, 0, sizeof fy);
	for (*fx = *fy = i = 1; i &lt;= n; ++i) if (!~ban[i]) for (j = Rx; j &gt;= s[i]; --j) add(fx[j], fx[j - s[i]]);
	for (i = 1; i &lt;= C; ++i)
		if (!(c[i].empty() || banC[i])) {p = 0; for (int sc : c[i]) p += s[sc]; for (j = Ry; j &gt;= p; --j) add(fy[j], fy[j - p]);}

	memset(f, 0, sizeof f), memset(g, 0, sizeof f);
	**f = 1, Dx = Dy = 0;
	for (i = 1; i &lt;= C; ++i) if (banC[i]) {
		p = 0;
		for (j = 0; j &lt;= Dy; ++j) memcpy(g[j], f[j], (Dx + 1) &lt;&lt; 2);
		for (int sc : c[i])
			switch (Dx = min(Dx + s[sc], Rx), p += s[sc], ban[sc]) {
				case -1: break;
				case 0:
					repjk f[j][k] = f[j][k - s[sc]]; memset(f[j], 0, s[sc] &lt;&lt; 2); }
					repjk add(g[j][k], g[j][k - s[sc]]); } break;
				case 1:
					repjk add(g[j][k], g[j][k - s[sc]]); } break;
				case 2:
					repjk add(f[j][k], f[j][k - s[sc]]); }
					repjk g[j][k] = g[j][k - s[sc]]; memset(g[j], 0, s[sc] &lt;&lt; 2); } break;
				case 3:
					repjk add(f[j][k], f[j][k - s[sc]]); } break;
			}
		Dy = min(Dy + p, Ry);
		for (j = Dy; j &gt;= p; --j) for (k = 0; k &lt;= Dx; ++k) add(f[j][k], g[j - p][k]);
	}
	for (j = 0; j &lt;= Ry; ++j) for (k = 1; k &lt;= Rx; ++k) add(f[j][k], f[j][k - 1]);
	for (j = 1; j &lt;= Ry; ++j) for (k = 0; k &lt;= Rx; ++k) add(f[j][k], f[j - 1][k]);
	for (j = 0; j &lt;= Ry; ++j)
		for (k = 0; k &lt;= Rx; ++k)
			Fy = (Fy + (ll)fx[k] * fy[j] % mod * range_sum(Lx - k, Rx - k, Ly - j, Ry - j)) % mod;
	printf("%lld\n", Fy);
}

int main() {
	int T;
	for (scanf("%d", &amp;T); T; --T) work();
	return 0;
}
</code><script>syntax_highlight()</script>
</pre></div>

		<h3>坑</h3>
		<p><strong>坑1：</strong>$L_x - a, L_y - b$ 可能小于 $0$，在计算区间和的时候注意判断一下。</p>
		<p><strong>坑2：</strong>在 <code>memcpy</code> 的时候注意复杂度，不要复制成了 $M^2$ 项。</p>
	</body>
</html>
